remove .node, .key -> (key,value): # returns removed element
        if key not in node: return
        let .found = node_with_key

        if found is leaf:
                delete .found, .key # key, value, edge

                # rebalance start
                # TODO: extract to separate procedure
                if .found is deficient
                        let .found_parent
                        let .found_right, .found_left
                        if .found_right exists AND .found_right more than min elements
                                rotate_left .found, .found_parent, .found_right
                        else if .found_left exists AND .found_left more than min elements
                                rotate_right .found_left, .found_parent, .found
                        else both siblings min
                                let .left, .right = pick sandwitch targets .found_left, .found_right, .found
                                copy separator .found_parent, .left
                                move elements .right, .left # from right to left
                                remove separator .found_parent
                                remove child .found_parent, .right
                                if .found_parent is root AND .found_parent empty
                                        make root (get child .found_parent)
                                else if .found_parent less than min
                                        rebalance .found_parent

                                

                # rebalance end
        else node not leaf
                let .right_child, .largest_key_right
                let .largest_element_right_subtree = remove .right_child, .largest_key_right (o)
                replace .found, .key, .largest_element_right_subtree # replace key value