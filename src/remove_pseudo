remove .node, .key -> (key,value): # returns removed element
        if key not in node: return

        let .found = node_with_key
        if found is leaf:
                delete .found, .key # key, value, edge
                rebalance .found
                # return key, value deleted
        else node not leaf
                let .right_child, .largest_key_right
                let .largest_element_right_subtree = remove .right_child, .largest_key_right (o)
                replace .found, .key, .largest_element_right_subtree # replace key value
                # return key, value replaced


# also will need access to the whole tree to get parent and siblings
rebalance .node
        if .node not deficient
                return

        let .parent
        let .right, .left
        if .right exists AND .right more than min elements
                rotate_left .node, .parent, .right
        else if .left exists AND .left more than min elements
                rotate_right .left, .parent, .node
        else both siblings min
                let .left, .right = pick sandwitch targets .left, .right, .node
                copy separator .parent, .left
                move elements .right, .left # from right to left
                remove separator .parent
                remove child .parent, .right
                if .parent is root AND .parent empty
                        make root (get child .parent)
                else if .parent less than min
                        rebalance .parent (o)
